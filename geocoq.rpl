import id

id = { [:alpha:] [[_][:alnum:]]* }
qualified_id = { id {"." id }* }
-- test qualified_id accepts "GeoCoq.Elements.OriginalProofs.lemma_angletrichotomy", "A", "proposition03"
-- test qualified_id rejects "lemma-angletrichotomy"


point = [:alpha:]
--test point accepts "A", "a"
prop_simple = id (point)+
prop_inversion = ( ("~")+ prop_simple ) / prop_simple
prop_conjunction = ( prop_inversion ( "/\\" prop_inversion )+ ) / prop_inversion
prop_disjunction = ( prop_conjunction ( "\\/" prop_conjunction )+ ) / prop_conjunction
prop = prop_disjunction
--test prop accepts "Lt C D A B", "~ LtA D E F A B C", "~ ~ Cong G D G E", "BetS E X F /\\ Cong E X C D", "BetS E X F \\/ Cong E X C D"


conclude_simple_prefix = "conclude_def" / "conclude" / "forward_using"
conclude_simple = conclude_simple_prefix ( id / ( "(" prop ")" ) )

until_semicolon_inclusive = { [^;]+ ";" }

conclude_auto_prefix = "apply" / "auto" / "eapply" / "epose" / "pose" / "unfold" / "unshelve"
conclude_auto_suffix = "assumption" / "auto" / "eauto"
conclude_auto = "remove_double_neg;"? conclude_auto_prefix (until_semicolon_inclusive !conclude_auto_suffix)* until_semicolon_inclusive conclude_auto_suffix

conclude_auto_using = "auto using" id

conclude_assert = "assert" "(" prop ")" "by auto;" ( ( "(" conclude_simple ")" ) / conclude_simple )

conclude_statement = conclude_simple / conclude_auto / conclude_auto_using / conclude_assert
-- test conclude_statement accepts "conclude lemma_differenceofparts"
-- test conclude_statement accepts "conclude (lemma_supplements2 D C B C G K F C G C B A)"
-- test conclude_statement accepts "eapply @axiom_5_line with (B:=U) (b:=u) (A:=A) (a:=a);assumption"
-- test conclude_statement accepts "eapply ( axiom_connectivity) with A F;auto"
-- test conclude_statement accepts "auto using parnotmeet"
-- test conclude_statement accepts "unfold OS;exists A;exists H;exists E;splits;auto"
-- test conclude_statement accepts "assert (nCol B C A) by auto;\n (forward_using lemma_NCorder)"
-- test conclude_statement accepts "assert (nCol C B F) by auto;forward_using lemma_NCorder"
-- test conclude_statement accepts "remove_double_neg;unfold CongA in *; assumption"

comment = "(*" { . !"*)" }+ "*)"
-- test comment accepts "(* comment\ncomment *)"

statement_assert = "assert" "("+ prop ")"+ "by" ( ( "(" conclude_statement ")" ) / "auto" ) ~ "."
unneeded_statement = "close." / "intros." / "Unshelve." / ( "exact" id ~ "." ) / "all: (exact A)." / "rename_H H;" / { conclude_statement "." } / "remove_exists;eauto 20."

cases_outro = "(*" ~ "*"? "cases" "*)"

grammar destruct_point = "[" point destruct_point? "]" end
destruct_intro = "let Tf:=fresh in" "assert (Tf:exists"
destruct_splitter = "destruct Tf as " destruct_point ";spliter."
destruct_assert = destruct_intro (point)+ "," "("? prop ")"+ "by (" conclude_statement ");" destruct_splitter

grammar
	-- See proposition_07 for an example of contradiction that is just "intro. contradict."
	assert_contradiction = "assert (" prop ")." "{" "intro." (lemma_statement)* "contradict." "}"

  assert_by_cases = "assert" "("+ prop ")"+ ~ "." "by cases on " "("+ prop ")"+ ~ "." (assert_case)+ cases_outro
	assert_case = "{" (lemma_statement)+ "}"
in
	lemma_statement = statement_assert / assert_by_cases / destruct_assert / assert_contradiction / unneeded_statement / comment
end
--test lemma_statement accepts "intros."
--test lemma_statement accepts "assert (Cong A B E F) by (conclude lemma_congruencesymmetric)."
--test lemma_statement accepts "let Tf:=fresh in\n assert (Tf:exists G, (BetS E G F /\\ Cong E G C D)) by (conclude_def Lt );destruct Tf as [G];spliter."
--test lemma_statement accepts "assert (~ eq A B).\n {\n intro.\n assert (Col A B C) by (conclude_def Col ).\n contradict.\n }"
--test lemma_statement accepts "assert (~ ~ Cong G D G E).\n {\n intro.\n contradict.\n }"
--test lemma_statement accepts "assert (eq b u).\n by cases on (BetS a u b \\/ eq b u).\n {\n close.\n }\n {\n close.\n }\n (** cases *)"
--test lemma_statement accepts "apply (proposition_15 A B C D E);assumption."
--test lemma_statement accepts "assert (neq E D) by auto."
--test lemma_statement accepts "let Tf:=fresh in\nassert (Tf:exists d a p q, (Out E C d /\\ Out E A a /\\ Out E C p /\\ Out E f q /\\ Cong E d E p /\\ Cong E a E q /\\ Cong d a p q /\\ nCol C E A))\nby (remove_double_neg;unfold CongA in *; assumption);destruct Tf as [d[a[p[q]]]];spliter."
--test lemma_statement accepts "assert (nCol F B C) by (assert (nCol C B F) by auto;forward_using lemma_NCorder)."

lemma_preamble_points = "forall" (point)+ ": Point"? ","
lemma_preamble_given = prop "->"
lemma_preamble_conclusion = ( "exists" (point)+ "," )? prop "."
lemma_preamble = lemma_preamble_points (lemma_preamble_given)+ lemma_preamble_conclusion
--test lemma_preamble_points accepts "forall A B C D E F,", "forall A B C D E : Point,"
--test lemma_preamble_given accepts "Lt C D A B ->"
--test lemma_preamble_conclusion accepts "exists X, BetS E X F."
--test lemma_preamble accepts "forall A B C D E F, \n Lt C D A B -> Cong E F A B ->\n exists X, BetS E X F."

lemma_intro = "Lemma" id ":" lemma_preamble "Proof."
lemma_outro = "Qed."

lemma = lemma_intro (lemma_statement)+ lemma_outro

section_start = "Section" id ~ "."
section_end = "End" id ~ "."

context = { "Context `{" id ":" id "}." }
--test context accepts "Context `{Ax:euclidean_neutral_ruler_compass}.", "Context `{Ax1:euclidean_neutral_ruler_compass}."

section = section_start context (lemma)+ section_end

require = "Require Export" qualified_id ~ "."
-- test require accepts "Require Export GeoCoq.Elements.OriginalProofs.lemma_angletrichotomy."

top = (require)* section+ $
