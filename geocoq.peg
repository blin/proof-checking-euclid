coq = require* section

require = "Require" ws "Export" ws qualified_id "." ws

section = section_start context lemma+ section_end

section_start = "Section" ws id "." ws
section_end = "End" ws id "." ws

context = "Context `{" id ":" id "}." ws

lemma = "Lemma" ws id ":" ws lemma_preamble "Proof." ws lemma_statement+ "Qed." ws

lemma_preamble = lemma_preamble_points lemma_preamble_given+ lemma_preamble_conclusion
lemma_preamble_points = "forall" ws point+ "," ws 
lemma_preamble_given = hypothesis "->" ws
lemma_preamble_conclusion = ("exists " point ", ")? expression "." ws

lemma_statement = statement_assert / statement_assert_def / destruct_assert / ("close." ws) / ("intros." ws) / ("Unshelve." ws) / ("exact" ws id "." ws)
statement_assert = "assert" ws "(" hypothesis ") by (conclude" ws id ")." ws
statement_assert_def = "assert" ws "(" hypothesis ") by (conclude_def" ws id ")." ws
destruct_assert = destruct_intro point+ "," ws "("? expression ")"+ " by (conclude" ws id ");" destruct_splitter ws
destruct_intro = "let Tf:=fresh in" ws "assert (Tf:exists" ws
destruct_splitter = "destruct Tf as " destruct_point ";spliter."
destruct_point = "[" point destruct_point? "]"

expression = conjunction
conjunction = (hypothesis ("/\\" ws hypothesis)+) / hypothesis
hypothesis = id point+
point = ~"[a-zA-Z]" ws?

qualified_id = ("."? id)*
id = ~"[a-zA-Z][a-zA-Z0-9_]*" ws?
ws = ~"\s+"
